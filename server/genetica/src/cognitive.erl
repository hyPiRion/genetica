-module(cognitive).
-import(genetica_utils, [clamp/3, rand_between/2, zip/2]).
-export([random_genotype_fn/1, phenotype_to_genotype_fn/1,
         genotype_to_phenotype_fn/1, fitness_fn/1, crossover_fn/1,
         mutation_fn/1, analyze_fn/2]).
-compile(export_all).

-record(ptype, {ref, gtype}).
-record(vertex, {name, tau, sigma, gain}).
-record(vstate, {o = 0, y = 0}).
-record(edge, {from, to}).
-record(block, {size, x, y}).

-define(AREA_HEIGHT, 15).
-define(AREA_WIDTH, 30).
-define(TRACKER_SIZE, 5).
-define(BLOCK_MAX_SIZE, 6).

rand_node(Name) ->
    #vertex{name = Name, sigma = rand_between(-10, 0),
            tau = rand_between(1, 2), gain = rand_between(1, 5)}.

random_genotype_fn(_) ->
    fun () ->
            [] ++
                %% edges to a and b, sans sigma
                [rand_between(-5, 5) || _X <- [a, b],
                                        _Y <- [0, 1, 2, 3, 4, a, b]]
                ++ %% edges to c and d, sans sigma
                [rand_between(-5, 5) || _X <- [c, d],
                                        _Y <- [a, b, c, d]]
                ++ %% nodes
                [rand_node(Name) || Name <- [a, b, c, d]]
    end.

phenotype_to_genotype_fn(_) ->
    fun (#ptype{gtype = G}) ->
            G
    end.


%%% Fitness function stuff
gen_fit(_G) ->
    rand_between(0, 100).

new_block(Ets) ->
    ets:insert(Ets, #block{size = random:uniform(?BLOCK_MAX_SIZE),
                           x = random:uniform(?AREA_WIDTH),
                           y = ?AREA_HEIGHT}).

%% Whether we can sense if we're at pos At, and the block is at spec. pos.
senses(At, #block{size = S, x = X}) ->
    case At >= ?AREA_WIDTH of
        true -> At_m = At - ?AREA_WIDTH;
        false -> At_m = At
    end,
    Cmp =
        fun(A) when A >= ?AREA_WIDTH ->
                A - ?AREA_WIDTH == At_m;
           (A) -> A == At_m
        end,
    lists:any(Cmp, lists:seq(X, X + S - 1)). %% - 1 to avoid blocksize+1

sense(Ets) ->
    [Block] = ets:lookup(Ets, block),
    [{tpos, P}] = ets:lookup(Ets, tpos),
    ets:insert(Ets, {sensed, [senses(At, Block) ||
                                 At <- lists:seq(P,P + ?TRACKER_SIZE - 1)]}).

%% Speed generated by a motor neuron
speed(X) when 0.5 =< X, X < 0.9 -> 1;
speed(X) when 0.9 =< X, X < 0.95 -> 2;
speed(X) when 0.95 =< X -> 4;
speed(_) -> 0.

actuate(Ets) ->
    [{c, _, #vstate{o = C}}] = ets:lookup(Ets, c),
    [{d, _, #vstate{o = D}}] = ets:lookup(Ets, d),
    [{tpos, OldPos}] = ets:lookup(Ets, tpos),
    RawPos = OldPos + speed(D) - speed(C),
    if RawPos < 0 ->
            NewPos = RawPos + ?AREA_WIDTH;
       RawPos >= ?AREA_WIDTH ->
            NewPos = RawPos - ?AREA_WIDTH;
       true ->
            NewPos = RawPos
    end,
    ets:insert(Ets, {tpos, NewPos}).

cognitive_step(_Ets) ->
    nil.

move_block(_Ets) ->
    nil.

step(Ets) ->
    sense(Ets),
    cognitive_step(Ets),
    actuate(Ets),
    move_block(Ets).

simulate_run(G) ->
    io:format("whole:~n~p~n~n", [G]),
    Ets = ets:new(x, [set]),
    Firsts = lists:zip([#edge{from=F, to=T} || T <- [a, b],
                                               F <- [1, 2, 3, 4, 5, a, b]],
                       lists:sublist(G, 2*7)),
    ets:insert(Ets, Firsts),
    io:format("first 14:~n~p~n~n", [Firsts]),
    OtherEdges = lists:zip([#edge{from=F, to=T} || T <- [c, d],
                                                   F <- [a, b, c, d]],
                           lists:sublist(G, 2*7 + 1, 2*4)),
    io:format("next 8:~n~p~n~n", [OtherEdges]),
    ets:insert(Ets, OtherEdges),
    Vertices = lists:sublist(G, 2*7 + 2*4 + 1, 4),
    io:format("and finally, vertices:~n~p~n~n", [Vertices]),
    ets:insert(Ets, [{Name, Vertex, #vstate{}} ||
                        Vertex = #vertex{name=Name} <- Vertices]),
    ets:insert(Ets, {tpos, 0}),
    ets:insert(Ets, {blocks_left, 39}),
    new_block(Ets),
    ets:insert(Ets, #block{size=6, x=27, y=15}),
    sense(Ets),
    All = ets:match_object(Ets, '_'),
    ets:delete(Ets),
    io:format("~P~n", [All, 100]).




refit(#ptype{gtype = G, ref = Ref} = P) ->
    Fitness = gen_fit(G),
    ets:insert(genetica_cognitive_ets, {Ref, Fitness}),
    ok.

setup_ets() ->
    case ets:info(genetica_cognitive_ets) of
        undefined -> ets:new(genetica_cognitive_ets, [set, named_table]);
        _ -> nil
    end,
    ok.


genotype_to_phenotype_fn(_) ->
    setup_ets(),
    %% Generate fitness fn here?
    fun (G) ->
            Ref = erlang:make_ref(),
            P = #ptype{gtype = G, ref = Ref},
            refit(P),
            P
    end.

fitness_fn(_) ->
    fun (#ptype{ref = Ref}, _) ->
            [{Ref, F}] = ets:lookup(genetica_cognitive_ets, Ref),
            F
    end.

crossover_fn(_) ->
    fun (G1, G2) ->
            G1
    end.

mutation_fn(_) ->
    fun (Geno) ->
            Geno
    end.

analyze_fn(Sock, Fitness_fn) ->
    fun (Pop) ->
            Fits = Fitness_fn(Pop),
            {_, #ptype{gtype = Best}} = lists:max(lists:zip(Fits, Pop)),
            Floats = [genetica_utils:avg(Fits), genetica_utils:std_dev(Fits),
                      lists:max(Fits), lists:min(Fits), Best],
            gen_tcp:send(Sock, io_lib:fwrite("~w~n", [Floats])),
            ets:delete_all_objects(genetica_cognitive_ets),
            %% ^ hack, flip over to gen_server for next task.
            lists:foreach(fun refit/1, Pop),
            ok
    end.


test() ->
    simulate_run((random_genotype_fn(nil))()).
